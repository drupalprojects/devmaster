<?php

/**
 * @file devshop_gitlab.module
 */

require_once 'vendor/autoload.php';

/**
 * Implements hook_menu().
 */
function devshop_gitlab_menu() {
  $items = array();

  $items['admin/devshop/gitlab'] = array(
    'title' => 'GitLab',
    'description' => 'DevShop GitLab Integration Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('devshop_gitlab_settings_form'),
    'access arguments' => array('administer projects'),
    'file' => 'admin.inc',
    'file path' => drupal_get_path('module', 'devshop_gitlab') . '/includes',
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/devshop/gitlab/add-key'] = array(
    'title' => 'Add public key to GitLab Account',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('devshop_gitlab_add_key_to_account'),
    'access arguments' => array('administer projects'),
    'file' => 'add-key.inc',
    'file path' => drupal_get_path('module', 'devshop_gitlab') . '/includes',
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implements hook_form_FORM_ID_alter() for project_node_form().
 */
function devshop_gitlab_form_project_node_form_alter(&$form, &$form_state, $form_id) {
  $node = $form['#node'];

  if ($node->project->git_provider != 'gitlab') {
    return;
  }

  //All settings git pull in project page
  $form['project']['settings']['gitlab'] = array(
      '#type' => 'fieldset',
      '#group' => 'project_settings',
      '#collapsible' => TRUE,
      '#collapsed' => arg(1) != $node->nid,
      '#title' => t('GitLab Integration'),
  );

  // Pull Requests create environments?
  // $form['gitlab']['pull_request_environments'] = array(
  $form['project']['settings']['gitlab']['pull_request_environments'] = array(
      '#type' => 'checkbox',
      '#title' => t('Create Environments for Pull Requests'),
      '#default_value' => isset($node->project->settings->gitlab) ? $node->project->settings->gitlab['pull_request_environments'] : FALSE,
      '#description' => t('If using GitLab, create a new environment when a new Pull Request is created.'),
  );

  // Delete Pull Request environments?
  // $form['gitlab']['pull_request_environments_delete'] = array(
  $form['project']['settings']['gitlab']['pull_request_environments_delete'] = array(
      '#type' => 'checkbox',
      '#title' => t('Delete Pull Request Environments'),
      '#default_value' => isset($node->project->settings->gitlab) ? $node->project->settings->gitlab['pull_request_environments_delete'] : FALSE,
      '#description' => t('When Pull Requests are closed, delete the environment.'),
      '#states' => array(
        'visible' => array(
          ':input[name="project[settings][gitlab][pull_request_environments]"]' => array('checked' => TRUE),
        ),
      ),
  );

  // Pull Request Environment method.
  // $form['gitlab']['pull_request_environments_method'] = array(

  $environments = array_keys($node->project->environments);
  $options = array(
    t('Install Drupal') => array(
        'devshop__gitlab__install' => empty($node->project->install_profile)? t('Default install profile.'): $node->project->install_profile,
    ),
    t('Clone another environment') => array(),
  );

  if (empty($environments)) {
    $options[t('Clone another environment')][] = t('No environments available. Check Project settings when you have one.');
  }
  else {
    $options[t('Clone another environment')] = array_combine($environments, $environments);
  }
  $form['project']['settings']['gitlab']['pull_request_environments_method'] = array(
      '#type' => 'select',
      '#title' => t('Pull Request Environment Creation Method'),
      '#default_value' => isset($node->project->settings->gitlab) ?
          $node->project->settings->gitlab['pull_request_environments_method'] : 'devshop__gitlab__install',
      '#description' => t('Select the method for creating the pull request environments.'),
      '#options' => $options,
      '#states' => array(
        'visible' => array(
          ':input[name="project[settings][gitlab][pull_request_environments]"]' => array('checked' => TRUE),
        ),
      ),
  );
  $form['project']['settings']['gitlab']['pull_request_reinstall'] = array(
    '#type' => 'checkbox',
    '#title' => t('Reinstall Pull Request Environments on every git push.'),
    '#default_value' => isset($node->project->settings->gitlab) ?
      $node->project->settings->gitlab['pull_request_reinstall'] : 0,
    '#description' => t('Destroy and reinstall Pull Request environments on every code push. All data in environments created via Pull Request will be destroyed.'),
    '#states' => array(
      'visible' => array(
        ':input[name="project[settings][gitlab][pull_request_environments]"]' => array('checked' => TRUE),
      ),
    ),
  );
}

/**
 * Implements hook_form_alter().
 */
function devshop_gitlab_form_devshop_project_create_step_git_alter(&$form, &$form_state, $form_id) {

  // Look for Token
  $token = variable_get('devshop_gitlab_token', '');

  if (empty($token)) {
    $form['connect']['#description'] = ' <div class="alert alert-danger">' . t('GitLab API Token was not found.') . ' ' . l(t('Configure DevShop GitLab Settings'), 'admin/devshop/gitlab') . '</div>';
    return;
  }

  if (devshop_gitlab_check_key()) {
    $form['connect']['#description'] = ' <div class="alert alert-success">' . t('The DevShop Public SSH Key has been found in your GitLab account.') . '</div>';
  }
  else {
    $form['connect']['#description'] = t('The DevShop Public SSH Key was not found in your account.') . '  ';

    $form['connect']['#description'] .= l(t('Add devshop public key to your GitLab account'), 'admin/devshop/gitlab/add-key', array(
            'query' => array(
              'destination' => $_GET['q'],
            ),
            'attributes' => array(
                'class' => 'btn btn-success'
            ),
        )) . '</div>';
    $form['connect']['#prefix'] = '<div class="alert alert-danger">';
    $form['connect']['#suffix'] = '</div>';
  }
}


/**
 * Implements hook_form_FORM_ID_alter() for project_node_form().
 */
function devshop_gitlab_form_devshop_project_create_step_sites_alter(&$form, &$form_state) {

  // Return if project isn't ready.
  if (empty($form['install_profile'])) {
    return;
  }

  // Return if there is no gitlab token
  $gitlab_token = variable_get('devshop_gitlab_token', '');
  if (empty($gitlab_token)) {
    return;
  }

  // Load project and gitlab
  $project_node = node_load($form['nid']['#value']);
  $project = $project_node->project;

  // Return if provider is not gitlab.
  if ($project->git_provider != 'gitlab') {
    return;
  }

  // Return if deploy method is not webhook.
  if ($project->settings->deploy['method'] != 'webhook') {
    return;
  }

  $repo = $project->gitlab_owner . '/' . $project->gitlab_repo;
  $repo_url = "http://gitlab.com/" . $repo;

  $form['gitlab_webhook'] = array(
    '#title' => t('Setup GitLab Webhook'),
    '#description' => t('Leave this box checked to automatically add a webhook to your GitLab Repository !link.', array(
      '!link' => l($repo, $repo_url, array(
          'attributes' => array(
            'target' => '_blank',
          ),
      ))
    )),
    '#type' => 'checkbox',
    '#default_value' => 1,
  );

  $form['#validate'][] = 'devshop_gitlab_project_create_webhook';
  $form['#submit'][] = 'devshop_gitlab_project_create_webhook';
}

/**
 * Extra submit hook for last step of project create form.
 */
function devshop_gitlab_project_create_webhook($form, $form_state) {

  // Return if box is not checked.
  if (empty($form_state['values']['gitlab_webhook'])) {
    return;
  }

  // Get Project
  $project_node = node_load($form['nid']['#value']);
  $project = $project_node->project;

  // Get GitLab client
  $client = new Gitlab\Client();
  $gitlab_token = variable_get('devshop_gitlab_token', '');
  $client->authenticate($gitlab_token, Gitlab\Client::AUTH_HTTP_TOKEN);

  // Create the webhook.
  try {
    $hook = $client->repo()->hooks()->create($project->gitlab_owner, $project->gitlab_repo, array(
        'name' => 'web',
        'active' => true,
        'events' => array(
            'push',
            'pull_request',
            'delete',
            'release',
        ),
        'config' => array(
            'url' => $project->webhook_url,
            'content_type' => 'json',
            'insecure_ssl' => '1',
        ),
    ));
  }
  catch (Gitlab\Exception\ValidationFailedException $e) {
    // For some reason, gitlab always returns an exception here when there is already webhooks on the project.
    if ($e->getMessage() == 'Validation Failed: Hook already exists on this repository') {
      drupal_set_message(t("GitLab webhook added, but there is already an existing webhook. Please check your repository's !link.", array(
          '!link' => l(t('Webhook Settings'), $project->git_repo_url . '/settings/hooks'),
      )), 'warning');
    }
    else {
      drupal_set_message(t('GitLab Validation Exception: !exception', array('!exception' => $e->getMessage())), 'error');
    }
  }
  catch (Gitlab\Exception\RuntimeException $e) {
    drupal_set_message(t('GitLab Runtime Exception: !exception', array('!exception' => $e->getMessage())), 'error');
  }
}

/**
 * Implements hook_node_load().
 */
function devshop_gitlab_node_load($nodes, $types) {
  if (count(array_intersect(array('project'), $types))) {
    foreach ($nodes as $nid => $node) {

      // Look for a pull request object.
      $pull_requests = db_query('SELECT * FROM {hosting_devshop_gitlab_pull_requests} WHERE project_nid = :project_nid', array(':project_nid' => $nid));
      foreach ($pull_requests as $pull_request) {
        if (!empty($pull_request->pull_request_object)) {
          $pull_request->pull_request_object = unserialize($pull_request->pull_request_object);
          if (isset($node->project->environments[$pull_request->environment_name])) {
            $node->project->environments[$pull_request->environment_name]->gitlab_pull_request = $pull_request;
          }
        }
      }

      // Parse gitlab owner and repo.
      if (isset($node->project) && $node->project->git_provider == 'gitlab') {
        $node->project->gitlab_owner =
          $parts = explode('/', parse_url($node->project->git_repo_url, PHP_URL_PATH));
        $node->project->gitlab_owner = $parts[1];
        $node->project->gitlab_repo = $parts[2];
      }
    }
  }

}

/**
 * Implements hook_node_update() for task insert.
 *
 * If task is a test run, send a "pending" commit status.
 */
function devshop_gitlab_node_update($node) {

  // Only act on test triggers.
  if ($node->type != 'task' || $node->type == 'task' && ($node->task_type != 'test' || $node->task_type != 'deploy')) {
    return;
  }

  // Load the site and check for environment.
  $site = node_load($node->rid);
  if (empty($site->environment) || empty($site->environment->gitlab_pull_request) || empty($site->environment->settings->deploy['test'])) {
    return;
  }

  try {
    $token = variable_get('devshop_gitlab_token', '');
    $client = new \Gitlab\Client();
    $client->authenticate($token, Gitlab\Client::AUTH_HTTP_TOKEN);

    // Create a deployment status
    $project = $site->project;
    $owner = $project->gitlab_owner;
    $repo = $project->gitlab_repo;
    $sha = $site->environment->gitlab_pull_request->pull_request_object->head->sha;

    $params = new stdClass();
    $params->state = 'pending';

    if ($node->task_type != 'test') {
      $params->target_url = url(
        "node/{$node->nid}",
        array('absolute' => true)
      );
      $params->description = t('DevShop: Run Tests');
      $params->context = 'devshop/tests';
    }
    elseif ($node->task_type != 'deploy') {
      $params->target_url = $site->environment->url;
      $params->description = t('DevShop: Deploy');
      $params->context = 'devshop/deploy';
    }

    // Post status to gitlab
    $status = $client->getHttpClient()->post("/repos/$owner/$repo/statuses/$sha", json_encode($params));

    watchdog('devshop_gitlab','Test run initiated. GitLab has been notified.');
  } catch (Gitlab\Exception\RuntimeException $e) {
    watchdog('devshop_gitlab', 'GitLab Runtime Error in devshop_gitlab_node_update(): ' . $e->getMessage());
  }
}


/**
* Implements hook_hosting_task_update_status()
*/
// function devshop_gitlab_hosting_task_update_status($task, $status) {
//
//  $task_types = array(
//    'test',
//    'import',
//    'devshop-deploy',
//  );
//
//  if (in_array($task->task_type, $task_types) && $task->ref->type == 'site' && isset($task->ref->environment->gitlab_pull_request)) {
//
//    // If autoloader is not available, return.
//    if (!file_exists(__DIR__ . '/vendor/autoload.php')) {
//      return;
//    }
//
//    // If project is not from gitlab, return.
//    if ($task->ref->project->git_provider != 'gitlab') {
//      return;
//    }
//
//    // Include vendors
//    require_once 'vendor/autoload.php';
//
//    drush_log('===========================================', 'ok');
//    drush_log('Notifying gitlab...', 'ok');
//
//    // Extract username and repo
//    list($s, $owner, $repo) = explode('/', parse_url($task->ref->project->git_repo_url, PHP_URL_PATH));
//
//    try {
//      $token = variable_get('devshop_gitlab_token', '');
//      $client = new \Gitlab\Client();
//      $client->authenticate($token, Gitlab\Client::AUTH_HTTP_TOKEN);
//
//      // Create a status
//      $sha = $task->ref->environment->gitlab_pull_request->pull_request_object->head->sha;
//
//      if ($task->task_type == 'devshop-deploy'){
//        $description = t('Deployed to Environment: ') . _hosting_parse_error_code($status);
//        $url = $task->ref->environment->url;
//      }
//      elseif ($task->task_type == 'test') {
//        $description = t('Tests: ') . _hosting_parse_error_code($status);
//        $url = url("devshop_tests/{$task->nid}/{$task->vid}", array('absolute' => TRUE));
//      }
//      else {
//        $description = 'Something happened...';
//        $url = $task->ref->environment->url;
//      }
//
//      if ($status == HOSTING_TASK_ERROR) {
//        $state = 'error';
//      }
//      elseif ($status == HOSTING_TASK_PROCESSING) {
//        $state = 'pending';
//      }
//      elseif ($status == HOSTING_TASK_SUCCESS || $status == HOSTING_TASK_WARNING) {
//        $state = 'success';
//      }
//      else {
//        $state = 'error';
//      }
//
//      $params = new stdClass();
//      $params->state = $state;
//      $params->target_url = $url;
//      $params->description = $description;
//      $params->context = 'devshop/' . $task->task_type;
//
//      $status = $client->getHttpClient()->post("/repos/$owner/$repo/statuses/$sha", json_encode($params));
//
//      drush_log('Status posted! ', 'ok');
//    } catch (Gitlab\Exception\RuntimeException $e) {
//      drush_log('GitLab API Error: ' . $e->getMessage(), 'error');
//      drush_log(l(t('Configure GitLab API'), 'admin/devshop/gitlab'), 'error');
//    } catch (Gitlab\Exception\ValidationFailedException $e) {
//      drush_log('GitLab API Error: ' . $e->getMessage(), 'error');
//    }
//
//    drush_log('done trying... ', 'ok');
//
//  }
// }

/**
 *
 */
function devshop_gitlab_comment($task, $status) {

  $output = array();
  $output[] = '> **DEVSHOP**';
  $output[] = '> ' . ucfirst($task->task_type) .  ": " . _hosting_parse_error_code($status);
  $output[] = '> Site: ' . $task->ref->environment->url;
  $output[] = '> Project: ' . url("node/{$task->ref->project->nid}", array('absolute' => TRUE));

  if ($task->task_type == 'test') {
    $output[] = 'Results: ' . url("node/{$task->nid}", array('absolute' => TRUE));
  }

  if ($task->task_type == 'import') {
    $output[] = t('Your environment is now available.');
  }

  return implode("\n", $output);
}



/**
 * GitLab action to take on webhook init
 */
function devshop_gitlab_webhook($project_node) {
  $headers = getallheaders();
  $project = $project_node->project;

  // Create a gitlab deployment
  require_once 'vendor/autoload.php';

  // @TODO: Handle form content from gitlab as well.
  if ($headers['Content-Type'] == 'application/json' || $headers['content-type'] == 'application/json') {
    $data = json_decode(file_get_contents('php://input'));

    $args = array();
    $args['cache'] = 1;

    if (isset($headers['X-Gitlab-Event'])) {
      $gitlab_event = $headers['X-Gitlab-Event'];
    }
    elseif (isset($headers['X-GitLab-Event'])) {
      $gitlab_event = $headers['X-GitLab-Event'];
    }
    else {
      $gitlab_event = '';
    }

    switch ($gitlab_event) {
      case 'ping':
        $message = 'Pong!';
        break;
      case 'push':

        // If push is for a deleted branch, don't do anything.
        if ($data->deleted && $data->after == "0000000000000000000000000000000000000000") {
          $message = 'Deleted ref detected.';
          break;
        }

        // Limit "Deploy" tasks to only run for the branches we have new code for..
        $git_ref = strtr($data->ref, array('refs/tags/' => '', 'refs/heads/' => ''));

        // Check for environments set to pull
        $environments_to_pull = array();
        $message = "Push Received for git ref $git_ref.";

        foreach ($project->environments as $environment_name => $environment) {

          // Only pull if deploy is not disabled or if environment is tracking a tag.
          if (
//            @TODO: Improve this. If a site install failed, it shows up as "disabled", so we should still do a git pull.
            $git_ref == $environment->git_ref &&
            !$environment->settings->pull_disabled &&
            !in_array($environment->git_ref, $project->settings->git['tags'])
          ) {
            $environments_to_pull[] = $environment->name;

            if (isset($environment->site) && $node = node_load($environment->site)) {

              // If project is set to reinstall pull request environments, and this is a pull request environment, run a forced install task.
              if (isset($project->settings->gitlab['pull_request_reinstall']) && $project->settings->gitlab['pull_request_reinstall'] && isset($environment->gitlab_pull_request)) {

                // Trigger deploy task to get latest code.
                // Pass no args to skip DB updates, cache clearing, etc.
                hosting_add_task($environment->site, 'devshop-deploy', array(
                  'git_ref' => $environment->git_ref,
                ));

                // Trigger "install" with force-reinstall
                hosting_add_task($environment->site, 'install', array('force-reinstall' => 1));
              }

              // Otherwise, just run a "deploy" task.
              else {

                // Default args to the environments deploy settings.
                $args = $environment->settings->deploy;
                $args['git_ref'] = $environment->git_ref;
                hosting_add_task($environment->site, 'devshop-deploy', $args);
              }
            }
          }
        }

        if (empty($environments_to_pull)) {
          $message .= "No environments tracking this branch. ";
        }
        else {
          $message .= "Deploying code to environments: " . implode(', ', $environments_to_pull);
        }
        break;

      case 'pull_request':
        // If pull request environments is enabled...
        if ($project->settings->gitlab['pull_request_environments']) {
          $message = 'Pull Request Received.';

          // @TODO: Handle forks?
          $branch = $data->pull_request->head->ref;

          // Determine environment branch.
          // @TODO: Make Configurable, allow branch names to be env name
          $environment_name = "pr" . $data->pull_request->number;
//          $environment_name = 'branch_' . str_replace('-', '_', $branch);
          $already_have_pr_info = FALSE;

          // When PR is opened... create new environment.
          if ($data->action == 'opened' || $data->action == 'reopened') {
            $message = "Detected Pull Request creation for $branch \n";
            if (isset($project->environments[$environment_name])) {
              $message = "Environment $environment_name already exists! Not creating one... \n";

              // @TODO: Check for environments that are being deleted.
              if (isset($project->environments[$environment_name]->gitlab_pull_request)) {
                $message .= "Already have a PR for $environment_name ... not inserting.";
                $already_have_pr_info = TRUE;
              }
            }
            else {
              // If method is "install"...
              if ($project->settings->gitlab['pull_request_environments_method'] == 'devshop__gitlab__install') {
                hosting_create_environment($project, $environment_name, $branch);
                $message .= "Environment $environment_name created for $project_node->title via installation profile.\n";
              }
              // Otherwise, it is a clone from live.
              elseif (isset($project->environments[$project->settings->gitlab['pull_request_environments_method']] )) {
                $source_env = $project->settings->gitlab['pull_request_environments_method'];
                hosting_create_environment($project, $environment_name, $branch, $source_env);
                $message .= "Environment $environment_name created for $project_node->title via cloning $source_env \n";
              }
              else {
                $message .= 'Unable to determine what to do! Check "Pull Request Environment Method" setting.';
              }
            }

            $project_node = node_load($project->nid);
            $project = $project_node->project;
            $environment = $project->environments[$environment_name];

            $owner = $project->gitlab_owner;
            $repo = $project->gitlab_repo;
            $message .= "\n About to try to create a deployment for $owner/$repo...  \n";

            // Send a "deployment" to gitlab.
            try {
              $token = variable_get('devshop_gitlab_token', '');
              $client = new \Gitlab\Client();
              $client->authenticate($token, Gitlab\Client::AUTH_HTTP_TOKEN);

              $sha = $data->pull_request->head->sha;

              $params = new stdClass();
              $params->ref = $sha;

              // In GitLab's API, "environment" is just a small string it displays on the pull request:
              $params->environment = $environment_name;
                devshop_environment_url($project, $environment_name)
              ;
              $params->required_contexts = array();

              // $message .= "\nEnvironment: " . print_r($environment, 1);
              $message .= "\nDeployment Params: " . print_r($params, 1);

              $post_url = "/repos/$owner/$repo/deployments";
              $deployment = json_decode($client->getHttpClient()->post($post_url, json_encode($params))->getBody(TRUE));

              // Save deployment to pull request data for later access.
              $data->pull_request->deployment = $deployment;

              $message .= " Deployment Created! \n";

              // Create deployment status
              $params = new stdClass();
              $params->state = 'pending';
              $params->target_url = $environment->url;;
              $params->description = t('New environment is being created.  Please stand by.');
              $deployment_status = $client->getHttpClient()->post("/repos/$owner/$repo/deployments/{$deployment->id}/statuses", json_encode($params));

              $message .= " Deployment Status Created! \n";

              // Set a commit status for this REF for devshop/deploy context
              $sha = $data->pull_request->head->sha;

              $params = new stdClass();
              $params->state = 'pending';
              $params->target_url = url("node/$environment->site", array('absolute' => TRUE));
              $params->description = t('DevShop: Deploy');
              $params->context = 'devshop/deploy';

              // Post status to gitlab
              $status = $client->getHttpClient()->post("/repos/$owner/$repo/statuses/$sha", json_encode($params));
              $message .= " Commit Status Created! \n";

              // Determine if we are going to run tests.
              // For now it is using the "live environment" setting.
              // @TODO: Once we add "deploy hooks" to "Project Settings: Environment Defaults" we will have to change this.

//              // If live environment is set to run tests on deploy...
//              $live_environment = $project->settings->live['live_environment'];
//              if ($project->environments[$live_environment]->settings->deploy['test']) {
//                $params = new stdClass();
//                $params->state = 'pending';
//                $params->target_url = url(
//                  "node/$environment->site",
//                  array('absolute' => true)
//                );
//                $params->description = t('DevShop: Run Tests');
//                $params->context = 'devshop/tests';
//
//                // Post status to gitlab
//                $status = $client->getHttpClient()->post(
//                  "/repos/$owner/$repo/statuses/$sha",
//                  json_encode($params)
//                );
//                $message .= " Commit Status for pending test run Created! \n";
//              }

            } catch (Gitlab\Exception\RuntimeException $e) {
              watchdog('devshop_gitlab', 'GitLab Runtime Error: ' . $e->getMessage());
              $message .= 'GitLab RunTimeException during PR Create: ' . $e->getMessage() . $e->getCode();

              if ($e->getCode() == '409') {
                $message .= "\n Branch is out of date! alert the developer!";

                // Send a failed commit status to alert to developer
                $params = new stdClass();
                $params->state = 'failure';
                $params->target_url = $project->git_repo_url;
                $params->description = t('Branch is out of date! Merge from default branch.');
                $params->context = 'devshop/merge';

                // Post status to gitlab
                $status = $client->getHttpClient()->post("/repos/$owner/$repo/statuses/$sha", json_encode($params));
              }
              else {
                http_response_code(500);
              }

            } catch (Gitlab\Exception\ValidationFailedException $e) {
              watchdog('devshop_gitlab', 'GitLab Validation Failed Error: ' . $e->getMessage());
              $message .= 'GitLab ValidationFailedException Error: ' . $e->getMessage();
            }

            // Insert PR record
            if (!$already_have_pr_info) {
              $info = new stdClass();
              $info->id = $data->pull_request->id;
              $info->number = $data->pull_request->number;
              $info->project_nid = $project->nid;
              $info->environment_name = $environment_name;
              $info->pull_request_object = serialize($data->pull_request);

              // Last minute check for existing PR info
              $results = db_select('hosting_devshop_gitlab_pull_requests', 'pr')
                ->condition('id', $data->pull_request->id)
                ->fields('pr', array('id'))
                ->execute()
                ->fetchAssoc();

              // If there are results, save $update param for drupal_write_record().
              if (empty($results)) {
                $update = array();
              }
              else {
                $update = array('id');
              }

              // Save environment record.
              try {
                drupal_write_record('hosting_devshop_gitlab_pull_requests', $info, $update);
                $message .= ' ' . t('Pull Request info saved to DevShop.');
              }
              catch (\PDOException $e) {
                $message .= 'Saving PR record failed: ' . $e->getMessage();
              }
            }
          }

          // When PR is updated, send a new deployment status environment.
          elseif ($data->action == 'synchronize') {

            // Create a new deployment
            $owner = $project->gitlab_owner;
            $repo = $project->gitlab_repo;
            $environment = $project->environments[$environment_name];

            // Environment might have been deleted.
            if (empty($environment)) {
              $message .= "Environment $environment_name not found in project $project->name.";
              continue;
            }

            $message .= "About to set deployment status for repo $owner/$repo using environment $environment_name  \n";
            $message .= "Environment: " . print_r($environment, 1);

            try {
              $token = variable_get('devshop_gitlab_token', '');
              $client = new \Gitlab\Client();
              $client->authenticate($token, Gitlab\Client::AUTH_HTTP_TOKEN);

              $sha = $data->pull_request->head->sha;

              $params = new stdClass();
              $params->ref = $sha;
              $params->environment = $environment->url;
              $params->required_contexts = array();
              $post_url = "/repos/$owner/$repo/deployments";
              $deployment = json_decode($client->getHttpClient()->post($post_url, json_encode($params))->getBody(TRUE));

              // Save deployment to pull request data for later access.
              $data->pull_request->deployment = $deployment;

              $message .= " Deployment Created! \n";

              // Create deployment status
              $deployment_id = $deployment->id;

              $params = new stdClass();
              $params->state = 'pending';
              $params->target_url = $environment->url;
              $params->description = t('Code is being deployed.  Please stand by.');

              $post_url = "/repos/$owner/$repo/deployments/{$deployment_id}/statuses";
              $message .= "Attempting to create deployment status: $post_url \n";

              $deployment_status = $client->getHttpClient()->post($post_url, json_encode($params));

              $message .= " Deployment Status Created! \n";

              // Set a commit status for this REF for devshop/deploy context
              $sha = $data->pull_request->head->sha;

              $params = new stdClass();
              $params->state = 'pending';
              $params->target_url = url("node/$project->nid", array('absolute' => TRUE));
              $params->description = t('DevShop: Deploy');
              $params->context = 'devshop/deploy';

              // Post status to gitlab
              $status = $client->getHttpClient()->post("/repos/$owner/$repo/statuses/$sha", json_encode($params));

              $message .= " Commit Status Created! \n";

              // If environment is configured to run tests, add another status.
              if (!empty($environment->settings->deploy['test'])) {
                $params = new stdClass();
                $params->state = 'pending';

                // @TODO: Add the link to the last "test" task here instead of the project.
                $params->target_url = url("node/$project->nid", array('absolute' => TRUE));
                $params->description = t('DevShop: Run Tests');
                $params->context = 'devshop/tests';

                // Post status to gitlab
                $status = $client->getHttpClient()->post("/repos/$owner/$repo/statuses/$sha", json_encode($params));

                $message .= " Commit Status Created for test runs! \n";
              }

            } catch (Gitlab\Exception\RuntimeException $e) {
              $log = 'GitLab API Error during PR Syncronize: ' . $e->getMessage() . $e->getCode();
              watchdog('devshop_gitlab', $log);

              if ($e->getCode() == '409') {
                $log .= "\n Out of date! alert the developer!";

                // Send a failed commit status to alert to developer
                $params = new stdClass();
                $params->state = 'failure';
                $params->target_url = $project->git_repo_url;
                $params->description = t('Branch is out of date! Merge from default branch.');
                $params->context = 'devshop/merge';

                // Post status to gitlab
                $status = $client->getHttpClient()->post("/repos/$owner/$repo/statuses/$sha", json_encode($params));
              }
              else {
                http_response_code(500);
              }
              $message .= $log . "\n";
            }


            // Update the PR record
            $info = new stdClass();
            $info->id = $data->pull_request->id;
            $info->number = $data->pull_request->number;
            $info->project_nid = $project->nid;
            $info->environment_name = $environment_name;
            $info->pull_request_object = serialize($data->pull_request);

            // Save environment record.
            $results = db_select('hosting_devshop_gitlab_pull_requests', 'pr')
              ->condition('id', $data->pull_request->id)
              ->fields('pr', array('id'))
              ->execute()
              ->fetchAssoc();

            // If there are results, save $update param for drupal_write_record().
            if (empty($results)) {
              $update = array();
            }
            else {
              $update = array('id');
            }

            // Save environment record.
            try {
              drupal_write_record('hosting_devshop_gitlab_pull_requests', $info, $update);
              $message .= ' ' . t('Pull Request info saved to DevShop.');
            }
            catch (\PDOException $e) {
              $message .= 'Saving PR record failed: ' . $e->getMessage();
            }
          }
          // When PR is closed, delete environment.
          elseif ($data->action == 'closed') {
            $message .= "Pull Request Closed \n";
            if ($project->settings->gitlab['pull_request_environments_delete']) {

              // If environment has a site... trigger it's deletion.
              // Platform deletion triggers after site deletion completes.
              if ($project->environments[$environment_name]->site) {
                hosting_add_task($project->environments[$environment_name]->site, 'delete', array('force' => 1));
                $message .= "Environment $environment_name (Site Node: {$project->environments[$environment_name]->site}) scheduled for deletion.";
              }
              // If environment has a platform... trigger it's deletion.
              elseif ($project->environments[$environment_name]->platform) {
                hosting_add_task($project->environments[$environment_name]->platform, 'delete');
                $message .= "Environment $environment_name (Platform Node: {$project->environments[$environment_name]->platform}) scheduled for deletion.";
              }
            }
          }
        }
        break;
    }

  }
  else {
    $message = 'GitLab Request Received, but not in JSON. Please make sure to configure the webhook to use Payload version: application/vnd.gitlab.v3+json';
  }
  return $message;
}

/**
 * Check the GitLab account for an SSH key.
 *
 * @return bool
 */
function devshop_gitlab_check_key() {
  $devshop_key = variable_get('devshop_public_key', '');
  $token = variable_get('devshop_gitlab_token', '');

  $client = new \Gitlab\Client();
  $client->authenticate($token, Gitlab\Client::AUTH_HTTP_TOKEN);

  try {
    $keys = $client->currentUser()->keys()->all();
  }
    // Happens when user has no public keys.
  catch (\GitLab\Exception\RuntimeException $e) {
    return FALSE;
  }
  $devshop_sshkey = sshkey_parse($devshop_key);
  $devshop_fingerprint = theme('sshkey_fingerprint', $devshop_sshkey);
  foreach ($keys as $key) {
    $ssh_key = sshkey_parse($key['key']);
    $fingerprint = theme('sshkey_fingerprint', $ssh_key);
    if ($fingerprint == $devshop_fingerprint) {
      return TRUE;
    }
  }
}
